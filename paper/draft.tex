% TODO: tempted to term this "Module-aware dynamic fragmentation, analysis, and reassembly" as Dialysis or refracture
\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}

\usepackage{soul}
\usepackage{xspace}
\usepackage{color}

\def\omit#1{}
\def\eg{{\em e.g.}, }
\def\ie{{\em i.e.}, }
\def\etc{{\em etc.}\xspace}
\def\vs{{\em vs.}\xspace}
% \newcommand{\heading}[1]{\vspace{4pt}\noindent\textbf{#1}\enspace}
% No vspace, coz Usenix class already has paragraph space
\newcommand{\heading}[1]{\vspace{2pt}\noindent\textbf{#1}\enspace}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\ttiny}[1]{\texttt{\scriptsize #1}}
\newcommand{\tcn}[1]{}

\newcommand{\cf}[1]{(\emph{Cf}.\S\ref{#1})}
\newcommand{\sx}[1]{(\S\ref{#1})}
\newcommand{\sys}{{\scshape Lya}\xspace}
\newcommand{\toy}{{\tt lya.js}\xspace}

\newcommand{\fra}{fragmentation\xspace} % fracture
\newcommand{\ana}{analysis\xspace}      % 
\newcommand{\ass}{reassembly\xspace}    % 
\newcommand{\dia}{\fra, \ana, and \ass}

\newcommand{\nv}[1]{[{\color{cyan}#1 --- Nikos}]}
\newcommand{\review}[1]{{\color{red}#1}}
\newcommand{\TODO}[1]{\hl{\textbf{TODO:} #1}\xspace}
\newcommand{\todo}[1]{\hl{#1}\xspace}
\newcommand{\fixme}[1]{{\color{red}#1}}
\newcommand{\tc}{(\todo{cite})\xspace}
%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Module Dialysis with Lya}

%for single author (just remove % characters)
\author{
{\rm Anonymous Author(s)}\\
Submission \#225, 12 pages; Additional Material:
% {\rm Grigoris Ntousakis}\\
% Technical University of Crete
% \and
% {\rm Nikos Vasilakis}\\
% Massachusetts Institute of Technology
}

\maketitle

\begin{abstract}

This paper introduces \emph{library dialysis}, a novel dynamic-analysis technique specifically tailored to applications with many third-party libraries.
The proliferation of third party libraries in applications is a recent trend in software engineering:
Libraries are becoming the cornerstone of modern 
  applications today rely on hundreds of libraries, to the point where code written by their nominal developers is becoming only a small fraction of their total line count.
% On the surface, such reliance is beneficial, as it lowers development costs, aids targeted software testing, and enables code reuse;
Despite its benefits, such over-reliance creates many challenges down the road, exactly because developers have little knowledge and understanding of each library's internals.
For example, security auditing and performance profiling---which are already challenging for monolithic applications---become extremely difficult in the presence of deeply-nested third-party code.

To address these challenges, library dialysis enables dynamic fragmentation, analysis, and re-assembly of applications at the level of individual modules.
One of its highlights is ease of deployment and use:
  (i) bolted onto existing runtime environments as a library, by wrapping and transforming the underlying module system
  (ii) allowing developers to extract information using the same abstractions as the host language---eschewing low-level instrumentation.
Due to the in the host language and at a coarser granularity than full-fledged dynamic analysis, module dialysis has the potential of low performance overheads while still providing important information.

Our dialysis prototype, \sys, targets the JavaScript ecosystem through the V8 runtime.
We use a series of case-studies to motivate \sys's design, and demonstrate how \sys allows the analysis of both individual modules as well as multi-module application programs---all with a surprisingly   low developer effort.
Experiments with \sys show that it adds a virtually imperceptible increase in the load latency of individual modules and that it scales well to real applications with hundreds of modules.

module-level analysis 

 and demonstrate how \sys provides high-performance by shadowing variables and transforming and wrapping values

Module dialysis can be bolted on existing language runtime environments in a language-agnostic fashion 
% By leveraging the ubiquity of third-party modules in today's applications
Such modules can be part of third-party packages or of the language's standard library;
  the latter is important for resources that are part of the broader environment where the application is executing, such as the operating system and the network.


, all with minimal developer effort.
As a result, 

Our implementation, \sys, simplifies the analysis 

\end{abstract}

\section{Introduction}
\label{intro}

Dynamic analysis is a type of program analysis performed by (and while) executing a program with the goal of identifying information about the program.
Such information may include the ability to infer execution invariants, check security constraints, and extract performance characteristics (multiple citations).

% Where dynamic analysis shines is
Dynamic analysis occupies a clear spot in the space of analysis has clear strengths and weaknesses.
  (i) involve current runtime information, such as the workload patterns
  (ii) have full visibility into the current execution (no path explosion),
  (iii) is the only viable option in dynamic programming languages---such as Ruby, Python, 
Examples of information not analyzable statically include runtime code evaluation, runtime introspection and reflection, as well as multi-lingual support.
Dynamic analysis is a particularly good fit for the analysis of dynamic languages.

Unfortunately, however, reaping these benefits comes with significant overheads in terms of developer effort and runtime performance.
One approach is to instrument the program requires an in-depth understanding of its internals and associated tools (\eg instruction set \etc).
Another approach is to modify the runtime environment of the program---\eg JavaScript's V8 engine.
Problem-specific solutions require significant investment outside the language's mental model and  

This paper proposes a novel approach to dynamic analysis, termed \emph{module-aware dynamic analysis} and implemented in \sys.
(i) at a somewhat coarser granularity, but still offering insights---and in a semantics-aware way tailored to the programming language.
(ii) bolt on
Our approach is applicable to any language that supports some notion of modularity, runtime introspection, and .
It plugs into the module-loading capability of the runtime system to insert key hooks for inserting 
After the parsing and interpretation phases of module loading complete, 
 which are then parsed and interpreted and 
Surprisingly, as we show in this paper, this architecture requires \emph{no} modifications to the language runtime---that is, it is backward-compatible with vanilla unmodified language runtime environments.

Its key strategy is to fracture applications at the boundaries of modules, instrument their interfaces (including direct accesses) using meta-programming capabilities, and recombine them 
By combining visiiblity into both built-in and third-party modules, \sys can get gather important information for 
at a much lower cost---both in terms of runtime performance and developer effort.

% to enable module-aware dynamic analysis are general
To achieve this, module-aware dynamic analysis leverages several techniques.
It plugs into the module manager;
wraps interfaces
(i) bolt on, meaning
(ii) high-performance, and 
(iii) low effort 

As shown later, these capabilities are generally available in all dynamic programming languages---\eg 

To demonstrate the effectiveness of our techniques, we
  (i) build a prototype of module-aware dynamic analysis for server-side JavaScript, called \sys; and
  (ii) develop a diverse set of analyses---including an allow/deny security analysis, a profiling analysis showing hot modules, a synthesis-oriented analysis on input-output data, and an analysis enforcing a static union-based type system at runtime.
  (iii)  and use \sys to evaluate these analyses on three levels:
    synthetic micro-benchmarks, that highlight certain features;
    single-module meso-benchmarks, that allow comparison with other dynamic analysis tools; and
    end-to-end full-application macro-benchmarks, that shows \sys's behavior of the system on realistic workloads. 
\sys's implementation and evaluation drives the design requirements for \sys and highlights the benefits of bolt-on module-aware dynamic analysis.

Our contributions, presented in \S\ref{bg}--\ref{impl} include:
\begin{itemize}
\item We characterize the shared needs of four case-study analyses~\sx{bg} for which an implementation from scratch would require a significant investment in terms of developer effort.
\item We present the design of the bolt-on module-oriented dynamic analysis~\sx{design}, which meets the requirements of the four case-study analyses.
\item We describe designs of four 
\item We discuss our prototype implementation, \sys, as a pluggable library for the JavaScript ecosystem~\sx{impl}; our evaluation shows that \sys incurs minimal performance overheads over the respective baseline runtime.
\end{itemize}

Aside from the sections corresponding to these contributions (\S\ref{bg}--\ref{impl}), the paper discusses \sys's limitations and its application to other environments~\sx{diss};
   it compares \sys with related prior work in the literature~\sx{rw}; and draws appropriate conclusions~\sx{end}.


\section{Background, Examples, and Goals}
\label{bg}

A single application today often incorporates multiple libraries\footnote{We use the terms ``library'', ``package'', and ``module'' interchangeably.} written and published by several different authors.
The emerging development process should (and to a certain extent, does) simplify the development and testing process;
  unfortunately, good abstractions are sealed (\ie they do not leak between abstraction layers), which makes the inspection of a library difficult.

\subsection{Modularity Today}

languages provide module systems

closely coupled with the runtime

A module uses a \ttt{import} function and returns an export .
Intuitively a map

Several details:
  same module at multiple levels, and the module cache
  sometime it's the same, some times it;s not
  module resolution algorithm

\subsection{Motivating Examples}

Having reviewed the building blocks and underlying techniques that power modularity, we now turn to examples of dynamic analysis that today are difficult or require specialized solutions. These examples illuminate key design requirements for \sys's implementation of module-level dynamic analysis.

\subsection{Design Goals}

We have briefly introduced four motivating analyses for extracting information about an application's dependencies.
While the challenges behind these analyses share several characteristics, today they remain largely unaddressed by dynamic analyses systems as these 

require highly specialized solutions often outside the core language,
do not leverage or offer semantic information at the level of module boundaries,
or lead to a high (often impractical) performance overheads due to the high granularity of their analyses.
These applications clearly illustrate the need for a system 
To summarize, these applications would appear to be served well by a system that:
\begin{itemize}
  \item Operates at the level of modules, both semantics and performance-wise
  \item Does not require learning a new tool or language---on the contrary,
    developers
  \item can be bolt onto an existing runtime as a library, regardless of whether 
  \item supports programmable analyses
\end{itemize}

In the next section we describe the design \sys, a new dynamic analyses
framework that satisfies these goals

\section{Module-aware Dynamic Analysis}
\label{design}


\section{Applications of Analysis}
\label{apps}


\section{Implementation: Lya}
\label{impl}

We implemented \sys for version 
We show where other implementations would diverge in table 1

The following subsections outline how module systems handle modules at runtime, by exemplifying the internals of Node.js.
It sketches the Node.js runtime~\sx{a}, the use of the module system~\sx{b}, and the internals of how module loading works~\sx{c}.

(1) why node.js
(2) Create a table of compatibility and show individual aspects

\heading{Module System}
Node.js' module system is implemented entirely in JavaScript.
It exposes \ttt{require}, a global-looking function for importing modules.
\fixme{Figure} above demonstrates the use of \ttt{require}.

% \begin{lstlisting}[language=js,mathescape,upquote=true]
% // -------------- [./main.js] -------------
% // importing point
% let Point = require("./point.js");
% Point.create(1, 1).print(); // => [1, 1]
% 
% // -------------- [./point.js] ------------
% let Point = function Point (x, y) {
%     this.x = x; this.y = y;
% };
% Point.prototype.print = function print () {
%   console.log([this.x, this.y]);
% };
% module.exports = {
%     create:  function create (x, y) {
%         return new Point(x, y);
%     }
% };
% \end{lstlisting}

In the example above, the main module (\ttt{main.js}) imports the \ttt{point.js} module using the \ttt{require} statement (line 3)
Functionality from the exporting module (\ttt{point.js}) that is expected to become available to the importing module (\ttt{main.js}) is assigned to a special \ttt{module.exports} object (line 13);
  the rest is module-private functionality.
Files and modules are in one-to-one correspondence (each file is treated as a separate module).
Method \ttt{require} is synchronous (\ie blocking):
  it will block execution until the module specified is loaded.
% ---and can be used to load built-in modules such as \ttt{http} and \ttt{fs}.
The module system is implemented in the \ttt{module} built-in module~\sx{c}, which locates, wraps, compiles, and executes the specified file.

\sys hooks into \ttt{module} and alters the return value of the \ttt{require} call that imports \ttt{point.js} (line 3).

\subsection{Implementation of the Module System}
\label{c}

At a very high level, loading a fresh module with \ttt{require("foo");} corresponds to the following five stages:

\begin{enumerate}
% \def\labelenumi{\arabic{enumi}.}
\item Resolution: identify the file to which the module specified corresponds, and locate it in the filesystem.
\item Loading: depending on the file type, use the corresponding loader (\eg V8 compiler for \ttt{js}, \ttt{JSON.parse} for \ttt{json} \etc).
\item Wrapping: wrap the module so that module-globals get encapsulated and Node.js globals (\eg \ttt{require}) get resolved.
\item Evaluation: evaluate the wrapped module in the current context, so that global names and top-level objects get resolved correctly.
\item Caching: add the module to a handful of module-related cache structures, for purposes of consistency and performance.
\end{enumerate}

% The resolution algorithm is somewhat convoluted, because it depends on several different facts (including the type of the file requested, whether it is a globally installed, whether it is a directory \etc).
% It does not require any \sys support beyond copying the directory that contains the source code of the all the modules onto the remote host.
\sys interposes on all of these steps to facilitate transformations.
Wrapping (3) and evaluation (4) are particularly interesting, because they allow \sys to interpose at the module boundary during runtime.
Before a module's code is evaluated, the Node.js module loader wraps the module so that
  (i) it keeps top-level variables (defined with \ttt{var}, \ttt{const} or \ttt{let}) scoped to the module rather than the global object; and
  (ii) it provides some global-looking variables that are actually specific to the module, such as the \ttt{module} and \ttt{exports} objects that the implementor can use to export values from the module and convenience variables---such as \ttt{\_\_filename} and \ttt{\_\_dirname}  containing the module's absolute filename and directory path, respectively.
True globals remaining are
  (i) the global objects as defined by the EcmaScript standard (\eg \ttt{Object}, \ttt{Function}, \ttt{Math}); and
  (ii) Node.js-specific globals (\eg \ttt{console}, \ttt{process}, \ttt{timer}).
These globals require further interposition.

% \begin{lstlisting}[language=js,mathescape,upquote=true]
% // Node.js will wrap a module with a function,
% // so as to bring certain names into scope
% // before compiling/evaluating code.
% let wrapped = "function (" +
%         "exports, require, module, " +
%         "__filename, __dirname, CTX) {" +
%     "let Math = CTX.Math" +
%     "let console = CTX.console" +
%     //...[more definitions]
%     moduleSource +
%   "});"
% \end{lstlisting}


\sys hooks into the wrapper function (the last variable in the function definition, \ttt{CTX}).
This trivial source-to-source transformation re-defines global variables as module-locals and initializes them with \sys-augmented values.
For example, \ttt{console} in the context of the module will be an \sys-created object that allows \sys to interpose on it.
Evaluation of the module passes an additional value to this function, which is the modified context.
As a result, any changes to the top-level objects and any global variables are accessible from the within the module.

% \begin{lstlisting}[language=js,mathescape,upquote=true]
% //Input: module ID e.g., absolute filepath
% let load = function (ID) {
%   if (cache[ID]) {
%      return cache[ID];
%   }
%   let m = {
%     exports: {}, id: ID, dir: path.resolve(ID)
%   };
%   let cm = v8.compile(wrapped);
%   let ii = iris.getImplicit(ID);
%   let c = iris.freshContext(ii);
%   cm(m.exports, this.require, m, ID, m.dir, c);
%   let ei = iris.getExplicit(ID);
%   m.exports = iris.wrap(m.exports, [ei] );
%   cache[ID] = m;
%   return m.exports;
% }
% \end{lstlisting}

The \ttt{load} method in the \ttt{Module} module combines evaluation (line 10) and caching (line 14) of the wrapped module.
After evaluation, invoking the compiled function generates the value that is assigned to \ttt{module.exports} from within the module (line 12).
\sys passes a freshly constructed context at that invocation, modified according to the implicit segment of the (PIC??) corresponding to the module being loaded.
Before returning the value of \ttt{module.exports}, \sys transforms it according to the explicit segment of the (PIC??) corresponding to the module being loaded.
Finally, the results of the entire process are placed into the module cache for later use.

\

\section{Evaluation}
\label{eval}

\subsection{Micro-benchmarks}
\label{micro}

\subsection{Single-module Benchmarks}
\label{meso}

\subsection{End-to-End Benchmarks}
\label{macro}

\section{Discussion and Limitations}
\label{diss}

\section{Related Work}
\label{rw}
Some citations to ensure we can see them~\cite{Christophe:2015:DAU:2819009.2819180, Keil:2013:EDA:2508168.2508176, Lehmann:2019:WFD:3297858.3304068, Sun:2018:EDA:3178372.3179527}.

\section{Conclusion}
\label{end}

% \section*{Acknowledgments}
% 
% \section*{Availability}

\bibliographystyle{plain}
\bibliography{bib}

\end{document}

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
