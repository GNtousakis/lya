% TODO: tempted to term this "Module-aware dynamic fracture, analysis, and reassembly" as Dialysis or refracture
\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}

\usepackage{soul}
\usepackage{xspace}
\usepackage{color}

\def\omit#1{}
\def\eg{{\em e.g.}, }
\def\ie{{\em i.e.}, }
\def\etc{{\em etc.}\xspace}
\def\vs{{\em vs.}\xspace}
% \newcommand{\heading}[1]{\vspace{4pt}\noindent\textbf{#1}\enspace}
% No vspace, coz Usenix class already has paragraph space
\newcommand{\heading}[1]{\vspace{2pt}\noindent\textbf{#1}\enspace}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\ttiny}[1]{\texttt{\scriptsize #1}}
\newcommand{\tcn}[1]{}

\newcommand{\cf}[1]{(\emph{Cf}.\S\ref{#1})}
\newcommand{\sx}[1]{(\S\ref{#1})}
\newcommand{\sys}{{\scshape Lya}\xspace}
\newcommand{\toy}{{\tt lya.js}\xspace}

\newcommand{\nv}[1]{[{\color{cyan}#1 --- Nikos}]}
\newcommand{\review}[1]{{\color{red}#1}}
\newcommand{\TODO}[1]{\hl{\textbf{TODO:} #1}\xspace}
\newcommand{\todo}[1]{\hl{#1}\xspace}
\newcommand{\fixme}[1]{{\color{red}#1}}
\newcommand{\tc}{(\todo{cite})\xspace}
%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Module-level Dynamic Analysis}

%for single author (just remove % characters)
\author{
{\rm Anonymous Author(s)}\\
Submission \#323, 12 pages; Additional Material:
% {\rm Grigoris Ntousakis}\\
% Technical University of Crete
% \and
% {\rm Nikos Vasilakis}\\
% Massachusetts Institute of Technology
}

\maketitle

\begin{abstract}
Modern software relies extensive on third-party libraries:
  recent studies on several ecosystems show that code written by an application's nominal developers is only a small fraction of its total line count.
Such over-reliance creates many challenges that appear later in the development process, exactly because developers have little knowledge and understanding of the module's internals.
For example, security auditing and performance profiling large applications in the presence of deeply-nested third-party code becomes cumbersome.

We introduce \emph{module dialysis}, a technique for dynamic analysis specifically tailored to module boundaries.
Module dialysis can be bolted on existing language runtime environments in a language-agnostic fashion, and enables module-aware application fracture, analysis, and reassembly at runtime.
Dialysis supports dynamic application fragmentation, analysis, and re-assembly at the level of individual modules.
Tailored at providing information at the (recursive) boundaries of third-party modules.
Such modules can be part of third-party packages or of the language's standard library;
  the latter is important for resources that are part of the broader environment where the application is executing, such as the operating system and the network.
By leveraging the ubiquity of third-party modules in today's applications, this analysis provides insights k

We use a series of case-study analyses to motivate \sys's design and demonstrate how \sys provides high-performance by shadowing variables and transforming and wrapping values

, all with minimal developer effort.
The key feature is that module-level analysis can be bolted onto existing runtime environments as a library, without requiring low-level intsrumentation and maintaing the semantics of..
Measurements of two COWL implementations, one in Firefox and one in Chromium, demonstrate a virtually imperceptible increase in page-load latency.

Our implementation, \sys, simplifies the analysis 

\end{abstract}

\section{Introduction}
\label{intro}

Dynamic analysis is a type of program analysis performed by (and while) executing a program with the goal of identifying information about the program.
Such information may include the ability to infer execution invariants, check security constraints, and extract performance characteristics (multiple citations).

% Where dynamic analysis shines is
Dynamic analysis occupies a clear spot in the space of analysis has clear strengths and weaknesses.
  (i) involve current runtime information, such as the workload patterns
  (ii) have full visibility into the current execution (no path explosion),
  (iii) is the only viable option in dynamic programming languages---such as Ruby, Python, 
Examples of information not analyzable statically include runtime code evaluation, runtime introspection and reflection, as well as multi-lingual support.
Dynamic analysis is a particularly good fit for the analysis of dynamic languages.

Unfortunately, however, reaping these benefits comes with significant overheads in terms of developer effort and runtime performance.
One approach is to instrument the program requires an in-depth understanding of its internals and associated tools (\eg instruction set \etc).
Another approach is to modify the runtime environment of the program---\eg JavaScript's V8 engine.
Problem-specific solutions require significant investment outside the language's mental model and  

This paper proposes a novel approach to dynamic analysis, termed \emph{module-aware dynamic analysis} and implemented in \sys.
(i) at a somewhat coarser granularity, but still offering insights---and in a semantics-aware way tailored to the programming language.
(ii) bolt on
Our approach is applicable to any language that supports some notion of modularity, runtime introspection, and .
It plugs into the module-loading capability of the runtime system to insert key hooks for inserting 
After the parsing and interpretation phases of module loading complete, 
 which are then parsed and interpreted and 
Surprisingly, as we show in this paper, this architecture requires \emph{no} modifications to the language runtime---that is, it is backward-compatible with vanilla unmodified language runtime environments.

Its key strategy is to fracture applications at the boundaries of modules, instrument their interfaces (including direct accesses) using meta-programming capabilities, and recombine them 
By combining visiiblity into both built-in and third-party modules, \sys can get gather important information for 
at a much lower cost---both in terms of runtime performance and developer effort.

% to enable module-aware dynamic analysis are general
To achieve this, module-aware dynamic analysis leverages several techniques.
It plugs into the module manager;
wraps interfaces
(i) bolt on, meaning
(ii) high-performance, and 
(iii) low effort 

As shown later, these capabilities are generally available in all dynamic programming languages---\eg 

To demonstrate the effectiveness of our techniques, we
  (i) build a prototype of module-aware dynamic analysis for server-side JavaScript, called \sys; and
  (ii) develop a diverse set of analyses---including an allow/deny security analysis, a profiling analysis showing hot modules, a synthesis-oriented analysis on input-output data, and an analysis enforcing a static union-based type system at runtime.
  (iii)  and use \sys to evaluate these analyses on three levels:
    synthetic micro-benchmarks, that highlight certain features;
    single-module meso-benchmarks, that allow comparison with other dynamic analysis tools; and
    end-to-end full-application macro-benchmarks, that shows \sys's behavior of the system on realistic workloads. 
\sys's implementation and evaluation drives the design requirements for \sys and highlights the benefits of bolt-on module-aware dynamic analysis.

Our contributions, presented in \S\ref{bg}--\ref{impl} include:
\begin{itemize}
\item We characterize the shared needs of four case-study analyses~\sx{bg} for which an implementation from scratch would require a significant investment in terms of developer effort.
\item We present the design of the bolt-on module-oriented dynamic analysis~\sx{design}, which meets the requirements of the four case-study analyses.
\item We describe designs of four 
\item We discuss our prototype implementation, \sys, as a pluggable library for the JavaScript ecosystem~\sx{impl}; our evaluation shows that \sys incurs minimal performance overheads over the respective baseline runtime.
\end{itemize}

Aside from the sections corresponding to these contributions (\S\ref{bg}--\ref{impl}), the paper discusses \sys's limitations and its application to other environments~\sx{diss};
   it compares \sys with related prior work in the literature~\sx{rw}; and draws appropriate conclusions~\sx{end}.


\section{Background, Examples, and Goals}
\label{bg}

\section{Module-aware Dialysis}
\label{design}

\section{Applications of Analysis}
\label{apps}

\section{Implementation}
\label{impl}

\section{Evaluation}
\label{eval}

\subsection{Micro-benchmarks}
\label{micro}

\subsection{Single-module Benchmarks}
\label{meso}

\subsection{End-to-End Benchmarks}
\label{macro}

\section{Discussion and Limitations}
\label{diss}

\section{Related Work}
\label{rw}
Some citations to ensure we can see them~\cite{Christophe:2015:DAU:2819009.2819180, Keil:2013:EDA:2508168.2508176, Lehmann:2019:WFD:3297858.3304068, Sun:2018:EDA:3178372.3179527}.

\section{Conclusion}
\label{end}

% \section*{Acknowledgments}
% 
% \section*{Availability}

\bibliographystyle{plain}
\bibliography{bib}

\end{document}

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
